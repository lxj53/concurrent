# 1 List

## 1.1 演变历史

List容器主要精力 Vector -> ArrayList -> Collections.sysnchronizedXXX -> CopyOnWriteList

## 1.2 优缺点

Vector：线程安全的，但是每个方法都加了sysnchronized方法，设计不合理，因为大多数时候不需要加锁

ArrayList：线程不安全的，常用于方法中，在没并发场景时使用的多

Collections.synchronizedXXX：当需要线程安全容器时，通过此方法，将容器变成线程安全的容器，实质就是方法加了synchronized

CopyOnWritedList：线程安全容器，利用CAS模式实现线程安全的容器，效率高，并发中常用该种模式。



# 2 队列

## 2.1 作用

线程安全的，专门用于高并发任务的容器，任务都扔在对列中，当线程池空闲时，从队列中取任务执行。

## 2.2 常用方法

offer()：新加一个元素，类似于容器的add方法，返回boolean类型变量，用于记录是否增加成功。但又不同于arraylist这些的add，增加不成功会抛错

poll()：取出顶端的元素，并移除

peek(): 取出顶端的元素，不移除

## 2.3 BlockingQueue作用

阻塞的队列，底层是用LockSupport实现的，常用于生产者和消费者

## 2.4 BlockingQueue常用方法

增加了两个阻塞的方法

put()：若队列是有界队列，往里增加时，会阻塞住，直至有空间可以放数据。

take()：若队列中已无数据，take时会阻塞，直至队列中有数据。

## 2.5 TransferQueue常用方法

transfer()：阻塞等待放到队列中的数据被取走后，当前线程才继续执行。

## 2.6 与List区别

提供了一些线程友好的API，例如offer()、poll()、peek()     还有阻塞队列的put()、take()



# 3 线程池

## 3.1 作用

开发只需定义任务，线程创建和执行交给线程池执行

线程可重复利用，避免频繁创建和销毁线程



## 3.2 线程池7个核心参数：

corePoolSize: 核心线程池大小。默认线程池创建后，线程池中线程数量为0，当有任务来时，就创建一个线程执行任务，当线程池中线程达到corePoolSize后，将任务丢到队列中

maximumPoolSize: 线程池中线程最大数量

keepAliveTime: 线程空闲多久后会被回收终止。默认线程池中线程大于corePoolSize后，线程空闲keepAliveTime被回收，直至线程数量不超过corePoolSize数量

unit: keepAliveTime的时间单位

workQueue: 阻塞队列，用于存储任务

threadFactory: 线程工厂，用于创建线程，阿里要求一般需要重写，因为线程名称需要自定义，便于查找问题

handler: 拒绝策略，当任务队列满后，并且线程已经到达最大线程数量，如何处理被拒绝的任务，默认带了四个拒绝策略，

​          但一般需要重写拒绝策略，可将被拒绝的任务写到数据库或者kafka



ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。

ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。

ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）

ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务



## 3.3 ThreadPool案例

```java
@Slf4j
public class Test03_ThreadPoolExecutor {
    /**
     * 总结：线程池的几个常用参数
     * corePoolSize: 核心线程池大小。默认线程池创建后，线程池中线程数量为0，当有任务来时，就创建一个线程执行任务，当线程池中线程达到corePoolSize后，将任务丢到队列中
     * maximumPoolSize: 线程池中线程最大数量
     * keepAliveTime: 线程空闲多久后会被回收终止。默认线程池中线程大于corePoolSize后，线程空闲keepAliveTime被回收，直至线程数量不超过corePoolSize数量
     * unit: keepAliveTime的时间单位
     * workQueue: 阻塞队列，用于存储任务
     * threadFactory: 线程工厂，用于创建线程，阿里要求一般需要重写，因为线程名称需要自定义，便于查找问题
     * handler: 拒绝策略，当任务队列满后，并且线程已经到达最大线程数量，如何处理被拒绝的任务，默认带了四个拒绝策略，
     *          但一般需要重写拒绝策略，可将被拒绝的任务写到数据库或者kafka
     *
     * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
     * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
     * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
     * ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
     *
     * @param args
     */
    public static void main(String[] args) {
        // 线程工厂和拒绝策略使用的默认的
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 4, 5, TimeUnit.SECONDS, new LinkedBlockingDeque<>(512), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());
        // 自定义拒绝策略
        ThreadPoolExecutor threadPoolExecutor2 = new ThreadPoolExecutor(2, 4, 5, TimeUnit.SECONDS, new LinkedBlockingDeque<>(512), Executors.defaultThreadFactory(), ((r, executor) -> {
            try {
                // 自定义拒绝策略，由blockingqueue的offer改成put阻塞方法
                executor.getQueue().put(r);
            } catch (InterruptedException e) {
                log.error("线程被打断");
            }
        }));

        // 创建常用线程的方法，但是阿里不推荐使用，避免使用的任务队列造成OOM内存溢出
        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(4);

        // 本质是个forkJoin线程池
        ExecutorService executorService = Executors.newWorkStealingPool();
    }
}
```



## 3.4 ForkJoinPool

采用分而治之的思想计算任务

```java
@Slf4j
public class Test04_ForkJoinThreadPool {
    /**
     * 总结：forkjoin线程池简单使用案例，自己定义任务的拆分方法，通过线程池计算任务是否需要拆分任务
     *
     * threadpoolExecutor和forkjoin区别：
     * threadpoolExecutor是一个线程队列，一个任务队列，都是从一个任务队列中拿任务
     * forkjoin类似于一个线程维护一个任务队列，当前线程的任务完成后，去其他任务队列中偷任务
     * @param args
     */
    public static void main(String[] args) {
        // for循环模式计算数值累加
        long[] numbers = LongStream.rangeClosed(1, 100000000).toArray();
        long beginTime = System.currentTimeMillis();
        long num = 0;
        for(long number : numbers) {
            num += number;
        }
        long endTime = System.currentTimeMillis();
        System.out.println("for循环计算结果：" + num + "耗时：" + (endTime-beginTime));

        // forkjoin模式计算累加，将任务拆分
        ForkJoinPool forkJoinPool = new ForkJoinPool(5);
        beginTime = System.currentTimeMillis();
        Long forkJoinNum = forkJoinPool.invoke(new SumTask(numbers, 0, numbers.length - 1));
        endTime = System.currentTimeMillis();
        System.out.println("forkjoin计算结果：" + forkJoinNum + "耗时：" + (endTime-beginTime));
        forkJoinPool.shutdown();
    }

    // 执行任务,可根据实际场景继承不同的类
    // RecursiveTask：有返回值
    // RecursiveAction：无返回值
    static class SumTask extends RecursiveTask<Long> {
        private long[] numbers;
        private int from;
        private int to;

        // 构造方法
        public SumTask(long[] numbers, int from, int to) {
            this.numbers = numbers;
            this.from = from;
            this.to = to;
        }

        @Override
        protected Long compute() {
            // 当需要计算的数字个数小于6时，直接采用for loop方式计算结果
            if (to - from < 6) {
                long total = 0;
                for (int i = from; i <= to; i++) {
                    total += numbers[i];
                }
                return total;
            } else {
                // 否则，把任务一分为二，递归拆分(注意此处有递归)到底拆分成多少分 需要根据具体情况而定
                int middle = (from + to) / 2;
                SumTask taskLeft = new SumTask(numbers, from, middle);
                SumTask taskRight = new SumTask(numbers, middle + 1, to);
                taskLeft.fork();
                taskRight.fork();
                return taskLeft.join() + taskRight.join();
            }
        }
    }
}
```



## 3.5 ThreadPool和ForkJoin区别

threadpoolExecutor是一个线程队列，一个任务队列，都是从一个任务队列中拿任务

forkjoin类似于一个线程维护一个任务队列，当前线程的任务完成后，去其他任务队列中偷任务