# 1 线程和进程区别

## 1.1 进程

进程是操作系统资源分配的基本单位（系统分配资源的基本单位，就是常见的运行程序）

## 1.2 线程

线程是处理器任务调度和执行的基本单位（CPU处理器具体执行的基本单位）

## 1.3 区别

1. 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。

2. 资源开销：每个进程具有独立的代码和数据空间，进程切换会有较大的开销。  同一个进程内的线程共享代码和数据空间，每个线程具有独立的程序计数器和栈内存，线程切换开销小。

## 1.4 java内存层面区别

<img src="https://cdn.jsdelivr.net/gh/lxj53/markdownPictures@main/img/20201217224727.png" alt="å¨è¿éæå¥å¾çæè¿°" style="zoom: 67%;" />

### 1.4.1 程序计数器可以私有么

保证线程切换后能恢复到正确的执行位置

### 1.4.2 栈可以私有么

保证线程中的局部变量不被别的线程访问到



# 2 创建线程的4种方式

## 2.1 继承Thread子类

## 2.2 实现runnable接口

## 2.3 实现Callable接口

## 2.4 使用线程池

```java
public class Test1_CreateThread {
    public static void main(String[] args) throws Exception {
        // 第一种方法: Thread对象的子类
        // 1.定义Thread对象的子类，并重写run方法，run方法就是线程需要完成的任务
        // 2.创建Thread子类的实例
        // 3.调用线程的start方法开启线程，不能直接调用run方法(直接调用run方法只是方法调用，无法开启新线程)
//        MyThread1 myThread = new MyThread1();
//        myThread.start();
//        Thread.sleep(1000);
//        System.out.println("主线程。。。");

        // 第二种方法：实现Runnable接口
        // 1.定义Runnable接口的实现类，并重写run方法
        // 2.创建runnable接口的实例，并用该实例作为Thread的target创建Thread对象，thread对象才是真正的线程对象
        // 3.调用Thread实例的start方法
        MyThread2 myThread2 = new MyThread2();
        Thread thread2 = new Thread(myThread2);
        thread2.start();
        Thread.sleep(1000);
        System.out.println("主线程。。。");

        // 第三种方法：实现Callable接口
        // Callable需要和Future结合使用（具体是Future接口的实现类FutureTask,FutureTask实现了获取子任务结果、判断子任务是否结束等方法）
        // 1.创建Callable接口的实现类，并重写call方法
        // 2.使用FutureTask封装Callable对象，该FutureTask对象封装了Callable对象call方法的返回值
        // 3.使用FutureTask对象作为Thread对象的Target创建并启动线程（因为FutureTask对象实现了Future和Runnable接口）
        // 4.调用FutureTask对象的get方法获取子线程的返回值
        MyThread3 myThread3 = new MyThread3();
        FutureTask<String> futureTask = new FutureTask<>(myThread3);
        // 因为FutureTask对象实现了Future和Runnable接口
        Thread thread3 = new Thread(futureTask);
        thread3.start();
        String taskResult = futureTask.get();
        System.out.println("子线程返回结果：" + taskResult);
        System.out.println("主线程。。。");

        // 第4种方法：使用线程池的方式


    }

    static class MyThread1 extends Thread {
        @Override
        public void run() {
            System.out.println("自定义线程1");
        }
    }

    static class MyThread2 implements Runnable {

        @Override
        public void run() {
            System.out.println("自定义线程2");
        }
    }

    static class MyThread3 implements Callable<String> {
        @Override
        public String call() throws Exception {
            return "自定义线程3";
        }
    }
}
```



# 3 线程常用的方法

## 3.1 sleep

## 3.2 yield

## 3.3 join

## 3.4 wait

```java
public class Test2_ThreadCommonMethod {
    public static void main(String[] args) {
        Thread myThread = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                System.out.println("子线程执行。。。" + i);
            }
        });
        myThread.start();
//        try {
//            // 主线程sleep 1000毫秒进入到阻塞状态
//            Thread.sleep(1000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
        // 主线程让出CPU进入到可执行状态，可能会立马被继续执行
        Thread.yield();

        for (int i = 0; i < 10; i++) {
            System.out.println("main线程执行第" + i + "次");
            if (i >= 4) {
                try {
                    // 在主线程调用其他线程的join方法，相当于主线程等待子线程执行完毕后再执行主线程，类似于方法调用
                    myThread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



# 4 线程常见的6种状态

详细说明见 [线程状态](https://blog.csdn.net/pange1991/article/details/53860651?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_p)

<img src="https://cdn.jsdelivr.net/gh/lxj53/markdownPictures@main/img/20201217230922.jpeg" alt="çº¿ç¨ç¶æå¾" style="zoom:67%;" />



# 5 synchronized

## 5.1 修饰实例方法

```java
@Slf4j
public class Test3_Synchronized1 {
    /**
     * 测试synchronized修饰实例方法。
     * 结论：
     * 1.若线程中的实例对象是同一对象时，可实现线程安全。
     * 2.若多个线程中的实例对象时不同的对象，但不同的对象共享同一份资源，
     * 由于不同的线程占用不同对象的锁资源，此时线程是不安全的
     *
     * @param args
     * @throws InterruptedException
     */
    public static void main(String[] args) throws InterruptedException {
        // 场景1：两个线程中的线程实例是相同的对象
        SynchronizedGood synchronizedGood = new SynchronizedGood();
        Thread thread1 = new Thread(synchronizedGood);
        Thread thread2 = new Thread(synchronizedGood);
        // 两个线程启动后执行run方法中的increase，由于有关键字synchronized
        // 因此需要先获取synchronizedGood对象的锁
        // 注意：此时两个线程的实例对象是同一个对象，因此竞争的是同一个对象的锁，
        // 两个线程在运行时存在互斥（同一时刻只能一个线程执行synchronized的代码块）
        thread1.start();
        thread2.start();
        // 等待thread1线程运行结束后，再执行主线程
        thread1.join();
        thread2.join();
        int result = synchronizedGood.getResult();
        // 执行结果为20000
        log.info("相同线程对象实例，运行后结果：{}", result);

        // 场景2：两个线程中的线程实例是不同的对象
        SynchronizedGood synchronizedGood3 = new SynchronizedGood();
        SynchronizedGood synchronizedGood4 = new SynchronizedGood();
        Thread thread3 = new Thread(synchronizedGood3);
        Thread thread4 = new Thread(synchronizedGood4);
        // 注意：此时两个线程的实例对象是两个不同的对象，但静态资源是共享的
        // 因此两个线程在执行时占用的是不同对象的锁，不存在互斥，因此最后的结果可能不是20000
        thread3.start();
        thread4.start();
        thread3.join();
        thread4.join();
        int result2 = synchronizedGood3.getResult();
        // 执行结果不为20000，解决方式：将synchronized作用于静态的方法，此时需要竞争的是class对象
        // 无论创建多少实例对象，class对象只有一个，因此竞争的是同一个对象的锁资源
        log.info("不同线程对象实例，运行后结果：{}", result2);

    }

    static class SynchronizedGood implements Runnable {
        // 线程共享资源
        static int i = 0;

        // 实例方法上的锁，线程执行时需先获取实例对象的锁
        private synchronized void increase() {
            for (int j = 0; j < 10000; j++) {
                i++;
            }
        }

        @Override
        public void run() {
            increase();
        }

        /**
         * 获取到实例对象共享的静态资源
         *
         * @return
         */
        private int getResult() {
            return i;
        }
    }
}
```

## 5.2 修饰静态方法

```java
@Slf4j
public class Test3_Synchronized2 {

    /**
     * 测试synchronized修饰静态的方法
     * 结论：
     * 由于class对象只有一个，因此即使多个线程要执行的target对象是不同对象，也可以实现线程安全
     *
     * @param args
     * @throws InterruptedException
     */
    public static void main(String[] args) throws InterruptedException {

        // 场景2：两个线程中的线程实例是不同的对象 （不同点：对象中现在synchronized修饰的是静态方法）
        SynchronizedGood synchronizedGood3 = new SynchronizedGood();
        SynchronizedGood synchronizedGood4 = new SynchronizedGood();
        Thread thread3 = new Thread(synchronizedGood3);
        Thread thread4 = new Thread(synchronizedGood4);
        thread3.start();
        thread4.start();
        thread3.join();
        thread4.join();
        int result2 = synchronizedGood3.getResult();
        // 执行结果为20000，因为此时锁的是class对象的锁，class对象只有一个
        log.info("不同线程对象实例，运行后结果：{}", result2);
    }

    static class SynchronizedGood implements Runnable {
        // 线程共享资源
        static int i = 0;

        // 静态方法上的锁，锁的是class对象，也就是SynchronizedGood对应的class对象
        private static synchronized void increase() {
            for (int j = 0; j < 10000; j++) {
                i++;
            }
        }

        @Override
        public void run() {
            increase();
        }

        /**
         * 获取到实例对象共享的静态资源
         *
         * @return
         */
        private int getResult() {
            return i;
        }
    }
}
```

## 5.3 局部代码块

```java
@Slf4j
public class Test3_Synchronized3 {

    /**
     * 测试同步代码块：避免整个方法比较大，存在耗时的方法，锁整个方法可能效率低，因此只锁需要同步的地方
     * 结论：
     * 可通过锁对象、this实例、class对象实现锁代码块
     *
     * @param args
     * @throws InterruptedException
     */
    public static void main(String[] args) throws InterruptedException {
        // 场景2：两个线程中的线程实例是不同的对象 （不同点：锁的是同一个静态对象）
        SynchronizedGood synchronizedGood3 = new SynchronizedGood();
        SynchronizedGood synchronizedGood4 = new SynchronizedGood();
        Thread thread3 = new Thread(synchronizedGood3);
        Thread thread4 = new Thread(synchronizedGood4);
        thread3.start();
        thread4.start();
        thread3.join();
        thread4.join();
        int result2 = synchronizedGood3.getResult();
        // 执行结果为20000，因为此时锁的是同一个静态对象
        log.info("不同线程对象实例，运行后结果：{}", result2);
    }

    static class SynchronizedGood implements Runnable {
        // 需要锁定的对象
        static SynchronizedGood instance = new SynchronizedGood();

        // 线程共享资源
        static int i = 0;

        private void increase() throws InterruptedException {
            // 模拟耗时操作
            Thread.sleep(1000);

            // 注意：三个方法不能同时放开，因为可能两个两个执行到instance和class地方，
            // 此时两个锁对象是不同的对象，相当于同时操作共享资源
            // 1.锁对象为同一个instance对象
            synchronized (instance) {
                for (int j = 0; j < 10000; j++) {
                    i++;
                }
            }

            // 2.锁对象为当前实例
            synchronized (this) {
                for (int j = 0; j < 10000; j++) {
                    i++;
                }
            }

            // 3.锁对象为class对象
            synchronized (SynchronizedGood.class) {
                for (int j = 0; j < 10000; j++) {
                    i++;
                }
            }
        }

        @SneakyThrows
        @Override
        public void run() {
            increase();
        }

        /**
         * 获取到实例对象共享的静态资源
         *
         * @return
         */
        private int getResult() {
            return i;
        }
    }

}
```

## 5.4 synchronized锁升级

### 5.4.1 synchronized重量级锁的代价：

java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统介入，**需要在用户态与核心态之间切换，这种切换会消耗大量的系统资源**，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。



### 5.4.2 无锁、偏向锁、自旋锁、重量级锁升级过程：

偏向锁：大多数情况下，都是一个线程多次获取一把锁，因此当线程获取锁时，将对象头中的threadId置成当前线程id,当重复进入时，判断threadId是否一致。一致则还是线程获取锁对象。

自旋锁：当多个线程竞争锁对象时，即第二个线程发现对象中偏向锁的线程还在使用锁，则线程进入自旋状态，期望在自旋的过程中获取到锁，避免刚进入阻塞状态锁就被释放了（阻塞线程需要CPU从用户态转到内核态，代价较大）。

重量级锁：自旋次数到了，或者第三个线程竞争锁资源，锁升级为重量级锁，线程进入到阻塞状态，避免cpu空转。



### 5.4.3 三种锁使用场景：

偏向锁：基本没有线程竞争的场景

自旋锁：少量线程竞争，且线程持有锁的时间不长（多个线程竞争会导致cpu空转，若单个线程持有时间长也会导致空转）

重量级锁：多个线程竞争，且锁持有时间长



# 6 volatile

## 6.1 volatile作用：

1. 线程可见性         详见Test4_Volatile1

2. 禁止指令重排序  详见Test4_Volatile2

 ```java
   @Slf4j
   public class Test4_Volatile1 {
       // 多个线程共享的资源，增加了volatile关键字的，字段被修改后可被其他线程立马看到
       private static volatile boolean runFlag = true;
   
       /**
        * 结论：volatile关键字具有线程可见性
        * 增加volatile关键字，字段修改后，可被其他线程立马可见，若没关键字，则不会立马可见，会一直空循环
        * 不加：不会输出结束日志信息
        * 增加：会输出结束日志信息
        *
        * @param args
        * @throws InterruptedException
        */
       public static void main(String[] args) throws InterruptedException {
           // 线程1判断runFlag标志，是否输出结束日志
           new Thread(() -> {
               while (runFlag) {
   
               }
               log.info("myThread线程运行结束。。。");
           }, "myThread").start();
   
           // 用于线程1完成启动
           TimeUnit.SECONDS.sleep(2);
   
           // 修改共享变量，判断线程1是否可见
           new Thread(() -> {
               log.info("myThread2线程启动");
               runFlag = false;
               log.info("runFlag被修改成false");
           }, "myThread2").start();
       }
   }
 ```

   

```java
@Slf4j
public class Test4_Volatile2 {

    // 实例对象的引用
    private static volatile Test4_Volatile2 INSTANCE = null;

    // 私有的构建方法，禁止外部创建
    private Test4_Volatile2() {

    }

    // 提供单例对象实现方法，外部通过此方法获取实例对象
    public Test4_Volatile2 getINSTANCE() {
        // 2 这一层判断增加的原因：不加也是可以的，但是增加的好处：先判断实例是否存在，存在则返回
        // 若不加，调用方法则会直接到synchronized关键字，需要先获取锁资源，然后再判断实例是否存在，效率低
        if (INSTANCE == null) {
            // 1 增加synchronized关键字，保证线程安全
            synchronized (this) {
                // 核心逻辑：如果实例引用为空，则创建实例对象
                if (INSTANCE == null) {
                    // 3 增加volatile作用：创建对象的指令对应三个，申请内存空间（对象属性是默认值）、对象初始化（对属性赋值）、将内存地址返回
                    // 不增加volatile，可能会将申请内存空间、返回地址的指令排在对象初始化指令前面，导致若两个线程同时进来，
                    // 第1线程进行到此时进行重排序，未初始化后就已返回，第2线程在最外层判断时，INSTANCE此时已为非空
                    // 即第2线程拿到了未初始化完成的对象，因此需要增加volatile关键字
                    INSTANCE = new Test4_Volatile2();
                }
            }
        }
        return INSTANCE;
    }
}
```



## 6.2 volatile和synchronized的区别

volatile不能保证原子性

```java
@Slf4j
public class Test4_Volatile3 {
    private static /*volatile*/ int count = 0;

    /**
     * 结论：volatile只能保证线程可见性，不能保证原子性
     *
     * @param args
     * @throws InterruptedException
     */
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 100000; i++) {
                // 需要加锁同步，count字段使用volatile字段修饰，只能保证线程读到的值是最新值，
                // 可能两个线程读到相同的值，然后都加一，此时相当于加了一次
                synchronized (Test4_Volatile3.class) {
                    count++;
                }
            }
        });
        t1.start();
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 100000; i++) {
                synchronized (Test4_Volatile3.class) {
                    count++;
                }
            }
        });
        t2.start();

        // 等待线程执行结束
        TimeUnit.SECONDS.sleep(2);
        log.info("count = {}", count);
    }
}
```



# 7 atomicXXX

## 7.1 atomicXXX由来

开发中常用的一些操作，避免开发人员每次都使用锁，jdk提供了一些原子操作的类



## 7.2 底层实现：

通过cas (compare and swap/set)操作实现原子操作（通过CPU原语实现）

```java
// v是属性值，expection是期望的值， newValue是需要更新后的值

cas(v, expection, newValue) {

​	if v == expection {

​		v = newValue

​		otherwise try again or fail

​	}

}
```



## 7.3 存在问题：

存在ABA问题，即第一个线程读到的值为A，即将去修改为其他的值C，第二个线程先将值A修改为B，然后修改为A，第一个线程cas时发现值仍为A，以为值未发生变化，将值修改为C。



基本数据类型：无所谓，反正都是要自增

引用数据类型：有影响。中间修改引用地址为B时，你有可能修改了B引用对象的属性值，造成影响。



## 7.4 解决方法

比较的时候加上version，每次修改后将version自增，cas时，将version信息也增加进去比较。



## 7.5 性能比较：

通常情况下：longAdder > atomic > synchronized，具体还需要看并发量  详见Test5_AtomicXXXVSsynchronizedVSLongAdder

atomic > synchronized原因：atomic是cas操作，不需要申请锁资源，synchronized需要申请锁资源

longAdder > atomic原因：atomic弊端：高并发意味着CAS的失败几率更高， 重试次数更多，越多线程重试，CAS失败几率又越高，变成恶性循环。高并发见longAdder优势



longAdder优势：

低并发时只用对一个块进行cas操作，和atomic一样

高并发时，对多个段进行cas,降低了单个value的热度，进行分段更新，同时可增加段的数量（用空间换取时间）



